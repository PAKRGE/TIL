비즈니스 로직 - 어플리케이션에서 해결하고자하는 문제의 핵심 기능과 규칙을 의미하며, 계산이나 데이터 치리를 포함한 로직

---

디렉토리 구조
- example
	-  app
		- controller - HTTP 요청을 받고 서비스를 호출하여 응답을 반환
		- service - 비즈니스 로직을 처리
		- model - 도메인 객체를 정의하는 클래스
		- repository - 데이터베이스와 상호작용

---

# 레이어드 아키텍처

**레이어드 아키텍처 (Layered Architecture)**는 소프트웨어 시스템을 여러 **계층 (Layer)**으로 나누어 각 계층이 특정 책임을 맡도록 설계하는 아키텍처 스타일입니다. 이 구조는 주로 **응집도**(같은 계층 안에서의 연관성)와 **결합도**(계층 간의 의존성)를 효과적으로 관리하기 위해 사용됩니다.

레이어드 아키텍처는 **모듈화**와 **책임 분리**를 기반으로 하며, 각 계층이 특정 역할을 하므로 유지보수, 확장성, 테스트 용이성 등을 높일 수 있습니다. 이 구조는 특히 **웹 애플리케이션**과 같은 분리된 시스템에 자주 사용됩니다.

## 레이어드 아키텍처의 기본 구조

일반적으로 레이어드 아키텍처는 다음과 같은 계층으로 나누어집니다:

1. **프레젠테이션 계층 (Presentation Layer)**
2. **비즈니스 로직 계층 (Business Logic Layer or Service Layer)**
3. **영속성 계층 (Persistence Layer or Data Access Layer)**
4. **도메인 계층 (Domain Layer)** _(선택적)_
5. **통합 계층 (Integration Layer)** _(선택적)_

각 계층은 명확하게 정의된 책임을 가지며, 다른 계층과의 의존성을 최소화하고 독립적으로 유지보수할 수 있습니다.

### 1. **프레젠테이션 계층 (Presentation Layer)**

- **책임**: 사용자와의 상호작용을 담당하는 계층입니다. 클라이언트(웹, 모바일 등)에서 요청을 받아 처리하고, 결과를 사용자에게 반환합니다.
- **주요 컴포넌트**:
    - **Controller** (Spring에서는 `@Controller`, `@RestController` 등)
    - **View** (HTML, JSP, Thymeleaf 등)
    - **DTO** (Data Transfer Object): 클라이언트와의 데이터 전송을 위한 객체
- **특징**:
    - **비즈니스 로직을 포함하지 않는다**. 모든 비즈니스 로직은 서비스 계층으로 위임된다.
    - 클라이언트 요청을 처리하고, 서비스 계층에 전달한 후 응답을 반환하는 역할을 한다.

### 2. **비즈니스 로직 계층 (Business Logic Layer or Service Layer)**

- **책임**: 시스템의 **핵심 비즈니스 로직**을 담당합니다. 데이터를 처리하고, 규칙에 따라 결과를 반환하거나 영속성 계층에 데이터를 저장합니다.
- **주요 컴포넌트**:
    - **Service** 클래스 (비즈니스 로직을 처리)
    - **DTO**: 클라이언트와 데이터 송수신 시 필요한 객체로, 엔티티 객체와 분리하여 사용하는 경우가 많습니다.
    - **Facade**: 여러 서비스 메서드를 하나로 묶어 간단한 인터페이스를 제공하는 경우도 있습니다.
- **특징**:
    - **핵심 비즈니스 로직**을 포함하며, 데이터베이스와의 상호작용은 영속성 계층에 위임한다.
    - 여러 도메인 객체를 결합하거나, 외부 API와의 상호작용을 관리할 수 있다.

### 3. **영속성 계층 (Persistence Layer or Data Access Layer)**

- **책임**: 데이터베이스와의 상호작용을 담당합니다. 데이터의 CRUD (Create, Read, Update, Delete) 작업을 처리합니다.
- **주요 컴포넌트**:
    - **Repository** (Spring Data JPA, MyBatis, Hibernate 등)
    - **DAO** (Data Access Object)
- **특징**:
    - 데이터베이스의 데이터를 **조회, 삽입, 수정, 삭제**하는 작업을 한다.
    - ORM(Object Relational Mapping) 프레임워크를 사용하여 데이터베이스와 객체 간의 매핑을 처리할 수 있다.

### 4. **도메인 계층 (Domain Layer)** (선택적)

- **책임**: 애플리케이션의 **비즈니스 모델**을 정의하는 계층입니다. 주로 엔티티 객체를 포함합니다.
- **주요 컴포넌트**:
    - **Entity** 객체 (도메인 모델): 시스템의 핵심 데이터를 표현하는 객체
    - **Value Object** (값 객체): 변하지 않는 값을 나타내는 객체 (예: 주소, 날짜 등)
    - **Aggregate**: 여러 엔티티들을 하나로 묶는 개념
- **특징**:
    - 도메인 모델을 정의하며, 시스템의 **핵심 비즈니스 데이터**를 캡슐화합니다.
    - 도메인 계층은 **서비스 계층**에서 사용됩니다.

### 5. **통합 계층 (Integration Layer)** (선택적)

- **책임**: 외부 시스템과의 통합을 담당하는 계층입니다. 다른 서비스나 시스템과의 상호작용을 관리합니다.
- **주요 컴포넌트**:
    - **API Client**: 다른 시스템의 API와 통신을 담당하는 클래스
    - **Message Queues**: 다른 시스템과 비동기적으로 통신할 때 사용하는 큐 시스템
- **특징**:
    - 외부 시스템과의 **연동**을 처리합니다.
    - 외부 API 호출, 메시지 큐와의 통신, 다른 데이터베이스 연동 등을 담당합니다.

---

### 레이어드 아키텍처의 장점

1. **유지보수성**:
    
    - 각 계층이 독립적이므로, 한 계층을 수정해도 다른 계층에 미치는 영향을 최소화할 수 있습니다.
    - 비즈니스 로직과 데이터 접근 로직을 분리하면, 특정 계층만 집중적으로 개선하거나 수정할 수 있습니다.
2. **확장성**:
    
    - 새로운 기능을 추가할 때 기존 계층에 영향을 주지 않고 새로운 계층이나 클래스를 추가할 수 있습니다.
    - 예를 들어, 새로운 외부 API 연동을 위해 통합 계층을 추가할 수 있습니다.
3. **테스트 용이성**:
    
    - 각 계층이 독립적으로 테스트 가능하기 때문에 **단위 테스트**가 용이합니다.
    - 예를 들어, 비즈니스 로직을 테스트하기 위해 데이터베이스 접근을 모킹(mocking)할 수 있습니다.
4. **구조의 명확성**:
    
    - 각 계층이 명확히 정의되어 있기 때문에 코드의 흐름을 이해하기 쉽고, 책임이 분리되어 있어 팀 내 협업이 원활합니다.
5. **재사용성**:
    
    - 서비스 계층에서 제공하는 비즈니스 로직은 다양한 컨트롤러나 다른 서비스에서 재사용할 수 있습니다.
    - **Repository**나 **Service**는 다른 애플리케이션이나 기능에서 재사용할 수 있습니다.

---

### 레이어드 아키텍처의 단점

1. **성능 문제**:
    - 각 계층을 통과하는 과정에서 **성능 저하**가 발생할 수 있습니다. 특히 **필요 없는 계층**을 통과하거나, 중간 계층에서의 호출이 많을 경우 성능에 영향을 줄 수 있습니다.
2. **과도한 분리**:
    - 너무 많은 계층을 나누면 오히려 코드가 복잡해지고, **구조가 과도하게 분리**되어 오히려 관리하기 어려울 수 있습니다.
3. **상호 의존성**:
    - 계층 간의 의존성이 많아질 경우, 각 계층이 서로 **강하게 결합**되어 관리가 어려워질 수 있습니다. 이를 해결하려면 **의존성 주입**(Dependency Injection)을 적절히 활용해야 합니다..